extends GenomeObject
class_name AbstractCorticalArea
## Holds details pertaining to a specific cortical area
## Should not be instantiated directly

# Main functionality for cortical area, and base details such as ID, name, and positions
#region Base Functionality

const TYPES_NOT_ALLOWED_TO_BE_MOVED_INTO_SUBREGION: Array[CORTICAL_AREA_TYPE] = [
	CORTICAL_AREA_TYPE.IPU,
	CORTICAL_AREA_TYPE.OPU,
	CORTICAL_AREA_TYPE.CORE,
]

## The type of cortical area, not 1-1 mapped with feagi
enum CORTICAL_AREA_TYPE {
	IPU,
	CORE,
	MEMORY,
	CUSTOM,
	OPU,
	UNKNOWN
}

## Any specific flags to be aware of for a cortical area? 
enum CORTICAL_FLAGS {
	EACH_AFFERENT_CONNECTION_MAX_ONE_MAPPING,
	EACH_EFFERENT_CONNECTION_MAX_ONE_MAPPING
}

signal cortical_visibility_updated(visibility: bool, this_cortical_area: AbstractCorticalArea)
signal cortical_neuron_per_vox_count_updated(density: int, this_cortical_area: AbstractCorticalArea)
signal cortical_synaptic_attractivity_updated(attractivity: int, this_cortical_area: AbstractCorticalArea)
signal changed_monitoring_membrane_potential(is_monitoring: bool)
signal changed_monitoring_synaptic_potential(is_monitoring: bool)
signal recieved_new_neuron_activation_data(activation_SVO_data: PackedByteArray) ## Contains only the SVO structure byte data, not the headers!


## Unique identifier of the cortical area, generated by FEAGI
var cortical_ID: StringName:
	get: return _genome_ID



## The base type of cortical area as understood by FEAGI
var cortical_type: CORTICAL_AREA_TYPE:
	get:  return _get_group()

var type_as_string: StringName:
	get: return AbstractCorticalArea.cortical_type_to_str(_get_group())

## Is cortical area activity visible?
var cortical_visibility: bool:
	get: return _cortical_visiblity

var cortical_neuron_per_vox_count: int:
	get: return _cortical_neuron_per_vox_count

var cortical_synaptic_attractivity: int:
	get: return _cortical_synaptic_attractivity

var SVO_neuron_activations: PackedByteArray:
	get: return _SVO_neuron_activations

var neuron_count: int:
	get: return AbstractCorticalArea.get_neuron_count(_dimensions_3D, _cortical_neuron_per_vox_count)

var are_details_placeholder_data: bool = true ## We don't have the true values for details yet

## Has a 2D location been specified in FEAGI yet or is still unknown?
var is_coordinates_2D_available: bool:
	get:  return _coordinates_2D_available

## Has a 3D location been specified in FEAGI yet or is still unknown?
var is_coordinates_3D_available: bool:
	get:  return _coordinates_3D_available

## Can a user edit the name of this cortical area?
var user_can_edit_name: bool:
	get: return _user_can_edit_name()

## Can a user edit the dimensions of this cortical area?
var user_can_edit_dimensions_directly: bool:
	get: return _user_can_edit_dimensions_directly()

## Can a user edit the dimensions of this cortical area?
var user_can_delete_this_area: bool:
	get: return _user_can_delete_area()

var user_can_edit_cortical_neuron_per_vox_count: bool:
	get: return _user_can_edit_cortical_neuron_per_vox_count()

var user_can_edit_cortical_synaptic_attractivity: bool:
	get: return _user_can_edit_cortical_synaptic_attractivity()

var user_can_clone_this_cortical_area: bool:
	get: return _user_can_clone_this_area()

var can_exist_in_subregion: bool:
	get: return !(cortical_type in TYPES_NOT_ALLOWED_TO_BE_MOVED_INTO_SUBREGION)
	#get: return _area_can_exist_in_subregion()

var has_neuron_firing_parameters: bool:
	get:  return _has_neuron_firing_parameters()

var has_memory_parameters: bool:
	get: return _has_memory_parameters()

# Private Properties
var _cortical_neuron_per_vox_count: int = 1
var _cortical_synaptic_attractivity: int = 100
var _coordinates_2D_available: bool = false  # if coordinates_2D are available from FEAGI
var _coordinates_3D_available: bool = false  # if coordinates_3D are available from FEAGI
var _cortical_visiblity: bool = true
var _SVO_neuron_activations: PackedByteArray = []

static func do_cortical_areas_have_matching_values_for_property(areas: Array[AbstractCorticalArea], composition_section_name: StringName, property_name: StringName) -> bool:
	var differences: int = -1 # first one will always fail
	var previous_value: Variant = null
	var current_value: Variant = null
	#TODO for vectors, to have per element diffs, branch out from here
	for area in areas:
		current_value = area.return_property_by_name_and_section(composition_section_name, property_name)
		if current_value == null:
			return false # if the property doesnt exist
		if previous_value != current_value:
			differences += 1
			if differences > 0:
				# Differences
				return false
			previous_value = current_value
		continue
	# If we got here, values are identical
	return true

## Array of Cortical Areas to Array of Cortical IDs
static func cortical_area_array_to_ID_array(arr: Array[AbstractCorticalArea]) -> Array[StringName]:
	var output: Array[StringName] = []
	for area: AbstractCorticalArea in arr:
		output.append(area.cortical_ID)
	return output

## From a string of cortical type, returns the cortical type enum
static func cortical_type_str_to_type(cortical_type_raw: String) -> CORTICAL_AREA_TYPE:
	cortical_type_raw = cortical_type_raw.to_upper()
	if cortical_type_raw in CORTICAL_AREA_TYPE.keys():
		return CORTICAL_AREA_TYPE[cortical_type_raw]
	else:
		push_error("Unknown Cortical Type " + cortical_type_raw +". Marking as INVALID!")
		return CORTICAL_AREA_TYPE.UNKNOWN

## From a human readable string of cortical type, to cortical type enum
static func cortical_type_human_readable_str_to_type(cortical_type_raw: String) -> CORTICAL_AREA_TYPE:
	cortical_type_raw = cortical_type_raw.to_lower()
	match(cortical_type_raw):
		"input":
			return CORTICAL_AREA_TYPE.IPU
		"output":
			return CORTICAL_AREA_TYPE.OPU
		"core":
			return CORTICAL_AREA_TYPE.CORE
		"interconnect":
			return CORTICAL_AREA_TYPE.CUSTOM
		"memory":
			return CORTICAL_AREA_TYPE.MEMORY
		_:
			return CORTICAL_AREA_TYPE.UNKNOWN

## Filters through a GenomeObject array to output only [AbstractCorticalArea]s
static func genome_array_to_cortical_area_array(genome_objects: Array[GenomeObject]) -> Array[AbstractCorticalArea]:
	var output: Array[AbstractCorticalArea] = []
	for genome in genome_objects:
		if genome is AbstractCorticalArea:
			output.append(genome)
	return output

## If any of the given cortical areas are of a type specified, returns true
static func array_contains_cortical_area_of_types(areas: Array[AbstractCorticalArea], types: Array[AbstractCorticalArea.CORTICAL_AREA_TYPE]) -> bool:
	for area in areas:
		if area.cortical_type in types:
			return true
	return false

## Returns true only if all given cortical areas can be allowed in subregions
static func can_all_areas_exist_in_subregion(areas: Array[AbstractCorticalArea]) -> bool:
	for area in areas:
		if !area.can_exist_in_subregion:
			return false
	return true

static func can_all_areas_be_deleted(areas: Array[AbstractCorticalArea]) -> bool:
	for area in areas:
		if !area.user_can_delete_this_area:
			return false
	return true

## Given a cortical type enum, return the string
static func cortical_type_to_str(cortical_type: CORTICAL_AREA_TYPE) -> StringName:
	return CORTICAL_AREA_TYPE.keys()[cortical_type]

static func get_neuron_count(dimensions: Vector3i, density: float) -> int:
	return int(float(dimensions.x * dimensions.y * dimensions.z) * density)

static func array_of_cortical_areas_to_array_of_cortical_IDs(arr: Array[AbstractCorticalArea]) -> Array[StringName]:
	var output: Array[StringName] = []
	for e in arr:
		output.append(e.cortical_ID)
	return output

## If all cortical areas in an array are of the same type, return that type enum, otherwise return CORTICAL_AREA_TYPE.UNKNOWN
static func array_oc_cortical_areas_type_identification(areas: Array[AbstractCorticalArea]) -> CORTICAL_AREA_TYPE:
	if len(areas) == 0:
		return CORTICAL_AREA_TYPE.UNKNOWN
	var comparison: CORTICAL_AREA_TYPE = areas[0].cortical_type
	if len(areas) == 1:
		return comparison
	for i in range(1, len(areas)):
		if areas[i].cortical_type != comparison:
			return CORTICAL_AREA_TYPE.UNKNOWN
	return comparison

## If given a boolean property, returns true if all areas have this property true. otherwise, returns false, and returns false if property is invalid
static func boolean_property_of_all_cortical_areas_are_true(areas: Array[AbstractCorticalArea], property: StringName) -> bool:
	for area in areas:
		if area.get(property) == null:
			return false
		if area.get(property) != true:
			return false
	return true

## DO NOT init this object directly! use a subclass!
func _init(ID: StringName, cortical_name: StringName, cortical_dimensions: Vector3i, parent_region: BrainRegion, visiblity: bool = true):
	_genome_ID = ID
	_friendly_name = cortical_name
	_dimensions_3D = cortical_dimensions
	_cortical_visiblity = visiblity
	_init_self_to_brain_region(parent_region)


## Called from [CorticalAreasCache] when cortical area is being deleted
func FEAGI_delete_cortical_area() -> void:
	#NOTE: Assumption is made that connections were already removed firstZ!
	_parent_region.FEAGI_genome_object_deregister_as_child(self)
	about_to_be_deleted.emit()
	# [CorticalAreasCache] then deletes this object

## Applies every detail from the dictionary from FEAGI
func FEAGI_apply_full_dictionary(data: Dictionary) -> void:
	if data == {}:
		return
	if "cortical_id" not in data.keys():
		push_error("Input dictionary to update cortical area %s is invalid! Skipping!" % _genome_ID)
		return
	if data["cortical_id"] != _genome_ID:
		push_error("Input dictionary to update cortical area %s has sent to %s! Skipping!" % [data["cortical_id"], _genome_ID])
		return
	
	if "cortical_name" in data.keys():
		FEAGI_change_friendly_name(data["cortical_name"])
	if "cortical_visibility" in data.keys():
		FEAGI_set_cortical_visibility(data["cortical_visibility"])
	if "cortical_dimensions" in data.keys():
		FEAGI_change_dimensions_3D(FEAGIUtils.array_to_vector3i(data["cortical_dimensions"]))
	
	if "coordinates_2d" in data.keys():
		if data["coordinates_2d"][0] == null:
			_coordinates_2D_available = false
		else:
			FEAGI_change_coordinates_2D(FEAGIUtils.array_to_vector2i(data["coordinates_2d"]))

	if "coordinates_3d" in data.keys():
		if data["coordinates_3d"] == null:
			_coordinates_3D_available = false
		else:
			FEAGI_change_coordinates_3D(FEAGIUtils.array_to_vector3i(data["coordinates_3d"]))
	
	if "parent_region_id" in data.keys():
		if !(data["parent_region_id"] in FeagiCore.feagi_local_cache.brain_regions.available_brain_regions):
			push_error("Unable to find new region ID %s for cortical area %s" % [data["parent_region_id"], cortical_ID])
			return
		var new_region: BrainRegion = FeagiCore.feagi_local_cache.brain_regions.available_brain_regions[data["parent_region_id"]]
		if new_region != current_parent_region:
			FEAGI_change_parent_brain_region(new_region)

			

	FEAGI_apply_detail_dictionary(data)

# NOTE: This function applies all details (but not base information such as name, visibility, dimensions or positions), and may be expanded in other cortical types
## Updates all cortical details in here from a dict from FEAGI
func FEAGI_apply_detail_dictionary(data: Dictionary) -> void:
	
	are_details_placeholder_data = false # Assuming if ANY data is updated here, that all data here is not placeholders
	# Cortical Parameters
	if "cortical_neuron_per_vox_count" in data.keys(): 
		_cortical_neuron_per_vox_count = data["cortical_neuron_per_vox_count"]
		cortical_neuron_per_vox_count_updated.emit(_cortical_neuron_per_vox_count, self)
	if "cortical_synaptic_attractivity" in data.keys(): 
		_cortical_synaptic_attractivity = data["cortical_synaptic_attractivity"]
		cortical_synaptic_attractivity_updated.emit(_cortical_synaptic_attractivity, self)
	
	
	post_synaptic_potential_paramamters.FEAGI_apply_detail_dictionary(data)

	return

func FEAGI_set_cortical_visibility(is_visible: bool) -> void:
	if is_visible == _cortical_visiblity:
		return
	_cortical_visiblity = is_visible
	cortical_visibility_updated.emit(_cortical_visiblity, self)

func FEAGI_set_cortical_neuron_per_vox_count(new_density: int) -> void:
	if new_density == _cortical_neuron_per_vox_count:
		return
	_cortical_neuron_per_vox_count = new_density
	cortical_neuron_per_vox_count_updated.emit(new_density, self)

func FEAGI_set_SVO_visualization_data(SVO_byte_structure: PackedByteArray) -> void:
	_SVO_neuron_activations = SVO_byte_structure
	recieved_new_neuron_activation_data.emit(SVO_byte_structure)

func FEAGI_set_no_visualizeation_data() -> void:
	if len(_SVO_neuron_activations) != 7:
		_SVO_neuron_activations = PackedByteArray([1,0,1,0, 0 ,255,255,255])
		recieved_new_neuron_activation_data.emit(_SVO_neuron_activations)
	

func FEAGI_set_cortical_synaptic_attractivity(new_attractivity: int) -> void:
	if new_attractivity == _cortical_synaptic_attractivity:
		return
	_cortical_synaptic_attractivity = new_attractivity
	cortical_synaptic_attractivity_updated.emit(new_attractivity, self)

func get_neuron_change_with_new_details(new_dimension: Vector3i, new_density: float) -> int:
	return AbstractCorticalArea.get_neuron_count(new_dimension, new_density) - neuron_count

## Returns the value of a property (optionally within a section). returns null if nonexistant
func return_property_by_name_and_section(composition_section_name: StringName, property_name: StringName) -> Variant:
	var section_object: RefCounted = null
	if composition_section_name != "":
		section_object = get(composition_section_name) # Assumption is that all cortical areas in the selected array have the section
		if section_object == null:
			return null # if the section doesnt exist
	else:
		section_object = self # to allow us to grab universal properties on the [AbstractCorticalArea] directly
	return section_object.get(property_name)

# The following functions are often overridden in child classes
func _get_group() -> CORTICAL_AREA_TYPE:
	## OVERRIDE THIS
	return CORTICAL_AREA_TYPE.UNKNOWN

func _user_can_edit_dimensions_directly() -> bool:
	return true

func _user_can_edit_name() -> bool:
	return true

func _user_can_delete_area() -> bool:
	return true

func _user_can_edit_cortical_neuron_per_vox_count() -> bool:
	return true

func _user_can_edit_cortical_synaptic_attractivity() -> bool:
	return true

func _user_can_clone_this_area() -> bool:
	return false

func _has_neuron_firing_parameters() -> bool:
	return false

func _has_memory_parameters() -> bool:
	return false

#endregion


# Functionality and references to how this cortical area is mapped / connected to other cortical areas / regions
#region Mapping

# NOTE: While we have connection links for pathing information for HOW connections are made to other objects, we 
# also have this to know WHAT we are connecting to, because sometimes we don't care about partial connections or regions

signal afferent_input_cortical_area_added(area: AbstractCorticalArea, mapping_set: InterCorticalMappingSet)
signal efferent_input_cortical_area_added(area: AbstractCorticalArea, mapping_set: InterCorticalMappingSet)
signal recursive_cortical_area_added(area: AbstractCorticalArea, mapping_set: InterCorticalMappingSet)
signal afferent_input_cortical_area_removed(area: AbstractCorticalArea, mapping_set: InterCorticalMappingSet)
signal efferent_input_cortical_area_removed(area: AbstractCorticalArea, mapping_set: InterCorticalMappingSet)
signal recursive_cortical_area_removed(area: AbstractCorticalArea, mapping_set: InterCorticalMappingSet)

var afferent_mappings: Dictionary: # Key'd by the source [AbstractCorticalArea] object, value is the related [InterCorticalMappingSet]
	get: return _afferent_mappings
var efferent_mappings: Dictionary: # Key'd by the destination [AbstractCorticalArea] object, value is the related [InterCorticalMappingSet]
	get: return _efferent_mappings
var recursive_mappings: Dictionary: # Key'd by the (self) [AbstractCorticalArea] object, value is the related [InterCorticalMappingSet]
	get: return _recursive_mappings

var _afferent_mappings: Dictionary = {}
var _efferent_mappings: Dictionary = {}
var _recursive_mappings: Dictionary = {} # technically, this will only be of size 0 or 1 lol

## Called by [InterCorticalMappingSet] during its init
func CACHE_mapping_set_register_an_afferent(mapping_set: InterCorticalMappingSet) -> void:
	_afferent_mappings[mapping_set.source_cortical_area] = mapping_set
	afferent_input_cortical_area_added.emit(mapping_set.source_cortical_area, mapping_set)

## Called by [InterCorticalMappingSet] during its init
func CACHE_mapping_set_register_an_efferent(mapping_set: InterCorticalMappingSet) -> void:
	_efferent_mappings[mapping_set.destination_cortical_area] = mapping_set
	efferent_input_cortical_area_added.emit(mapping_set.destination_cortical_area, mapping_set)

## Called by [InterCorticalMappingSet] during its init
func CACHE_mapping_set_register_a_recursive(mapping_set: InterCorticalMappingSet) -> void:
	_recursive_mappings[mapping_set.destination_cortical_area] = mapping_set
	recursive_cortical_area_added.emit(mapping_set.destination_cortical_area, mapping_set)

## Called by [InterCorticalMappingSet] during its init
func CACHE_mapping_set_deregister_an_afferent(mapping_set: InterCorticalMappingSet) -> void:
	_afferent_mappings.erase(mapping_set.source_cortical_area)
	afferent_input_cortical_area_removed.emit(mapping_set.source_cortical_area, mapping_set)

## Called by [InterCorticalMappingSet] during its init
func CACHE_mapping_set_deregister_an_efferent(mapping_set: InterCorticalMappingSet) -> void:
	_efferent_mappings.erase(mapping_set.destination_cortical_area)
	efferent_input_cortical_area_removed.emit(mapping_set.destination_cortical_area, mapping_set)

## Called by [InterCorticalMappingSet] during its init
func CACHE_mapping_set_deregister_a_rescursive(mapping_set: InterCorticalMappingSet) -> void:
	_recursive_mappings.erase(mapping_set.source_cortical_area)
	recursive_cortical_area_removed.emit(mapping_set.source_cortical_area, mapping_set)

func get_mapping_array_toward_cortical_area(destination: AbstractCorticalArea) -> Array[SingleMappingDefinition]:
	if destination in _efferent_mappings:
		return _efferent_mappings[destination].mappings
	if destination in _recursive_mappings:
		return _recursive_mappings[destination].mappings
	# no mapping exists between these areas, return an empty array!
	return []

#endregion

#region Post Synaptic Potential Parameters

## Holds all post synaptic potential paramamters
var post_synaptic_potential_paramamters: CorticalPropertyPostSynapticPotentialParameters = CorticalPropertyPostSynapticPotentialParameters.new(self)
#endregion

# Monitoring settings for this specific cortical area
#region Monitoring Settings
var is_monitoring_membrane_potential: bool
var is_monitoring_synaptic_potential: bool
#endregion
