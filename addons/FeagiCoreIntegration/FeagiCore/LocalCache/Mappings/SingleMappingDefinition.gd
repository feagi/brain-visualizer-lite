extends RefCounted
class_name SingleMappingDefinition
## A single mapping definition (IE morphology used and properties).
## NOTE: This object is generated a lot in memory as a form of passing data, not only as a reference in cache!
## WARNING: In the cache, this object is routinely thrown out and regenerated by [InterCorticalMappingSet], beware of storing this object from Feagi Cache by reference!

const DEFAULT_POSITIVE_SCALAR: Vector3i = Vector3i(1,1,1)
const DEFAULT_PSP_MULTIPLIER: float = 1.0
const DEFAULT_PLASTICITY: bool = false
const DEFAULT_PLASTICITY_CONSTANT: float = 1.0
const DEFAULT_LTP_MULTIPLIER: float = 1.0
const DEFAULT_LTD_MULTIPLIER: float = 1.0


var morphology_used: BaseMorphology:
	get: return _morphology_used
var scalar: Vector3i:
	get: return _scalar
var is_plastic: bool:
	get: return _plasticity_flag
var post_synaptic_current_multiplier: float:
	get: return _post_synaptic_current_multiplier
var plasticity_constant: float:
	get: return _plasticity_constant
var LTP_multiplier: float:
	get: return _LTP_multiplier
var LTD_multiplier: float:
	get: return _LTD_multiplier

var _morphology_used: BaseMorphology
var _scalar: Vector3i # must all be non-zero positive
var _post_synaptic_current_multiplier: float
var _plasticity_flag: bool
var _plasticity_constant: float
var _LTP_multiplier: float
var _LTD_multiplier: float

## Creates a mapping with default settings (given a morphology)
static func create_default_mapping(morphology: BaseMorphology) -> SingleMappingDefinition:
	return SingleMappingDefinition.new(morphology, DEFAULT_POSITIVE_SCALAR, DEFAULT_PSP_MULTIPLIER, DEFAULT_PLASTICITY)


## Given the dictionary from FEAGI directly creates a [SingleMappingDefinition] object
static func from_FEAGI_JSON(mapping_property: Dictionary) -> SingleMappingDefinition:
	if !(mapping_property["morphology_id"] in FeagiCore.feagi_local_cache.morphologies.available_morphologies.keys()):
		push_error("Unable to find morphology %s in cache when creating MappingProperty! Creating SingleMappingDefinition with null morphology!" % mapping_property["morphology_id"])
		return SingleMappingDefinition.create_default_mapping(null)
	var morphology_cached: BaseMorphology =  FeagiCore.feagi_local_cache.morphologies.available_morphologies[mapping_property["morphology_id"]]
	var scalar_used: Vector3i = FEAGIUtils.array_to_vector3i(mapping_property["morphology_scalar"])
	var psp_multiplier: float = mapping_property["postSynapticCurrent_multiplier"]
	var plasticity: bool = mapping_property["plasticity_flag"]
	if !plasticity:
		return SingleMappingDefinition.new(morphology_cached, scalar_used, psp_multiplier, plasticity)
	else:
		# failsafe since feagi can send invalid dicts sometimes
		if !"plasticity_constant" in mapping_property:
			mapping_property["plasticity_constant"] = 0.0
			push_error("FEAGI CORE: Feagi missing key for plasticity_constant for mapping!")
		if !"ltp_multiplier" in mapping_property:
			mapping_property["ltp_multiplier"] = 0.0
			push_error("FEAGI CORE: Feagi missing key for ltp_multiplier for mapping!")
		if !"ltd_multiplier" in mapping_property:
			mapping_property["ltd_multiplier"] = 0.0
			push_error("FEAGI CORE: Feagi missing key for ltd_multiplier for mapping!")
		var plasticity_constant_used: float = mapping_property["plasticity_constant"]
		var LTP_multiplier_used: float = mapping_property["ltp_multiplier"]
		var LTD_multiplier_used: float = mapping_property["ltd_multiplier"]
		return SingleMappingDefinition.new(morphology_cached, scalar_used, psp_multiplier, plasticity, plasticity_constant_used, LTP_multiplier_used, LTD_multiplier_used)


## Given an array of Dictionaries from FEAGI, directly output an array of [SingleMappingDefinitions]
static func from_FEAGI_JSON_array(mapping_dicts: Array[Dictionary]) -> Array[SingleMappingDefinition]:
	var output: Array[SingleMappingDefinition] = []
	for mapping_dict: Dictionary in mapping_dicts:
		output.append(SingleMappingDefinition.from_FEAGI_JSON(mapping_dict))
	return output

## Returns an array of the [SingleMappingDefinition] objects as FEAGI formatted dictionaries
static func to_FEAGI_JSON_array(input_mappings: Array[SingleMappingDefinition]) -> Array[Dictionary]:
	var output: Array[Dictionary] = []
	for mapping: SingleMappingDefinition in input_mappings:
		if mapping.is_morphology_valid():
			output.append(mapping.to_FEAGI_JSON())
		else:
			push_error("Exporting SingleMappingDefinition that has a null morphology. These placeholders will be skipped in the export in an attempt at stability, but this should never happen!")
	return output

## Returns an array with no duplicates of all morphologies within an array of [SingleMappingDefinition]
static func get_involved_morphologies(input_mappings: Array[SingleMappingDefinition]) -> Array[ BaseMorphology]:
	var morphologies_involved: Array[BaseMorphology] = []
	for mapping: SingleMappingDefinition in input_mappings:
		if !(mapping.morphology_used in morphologies_involved):
			morphologies_involved.append(mapping.morphology_used)
	return morphologies_involved


## Create Object
func _init(morphology: BaseMorphology, positive_scalar: Vector3i, psp_multilpier: float, plasticity: bool, 
	plasticity_constant_: float = DEFAULT_PLASTICITY_CONSTANT, ltp_multiplier: float = DEFAULT_LTP_MULTIPLIER,
	 ltd_multiplier: float = DEFAULT_LTD_MULTIPLIER):
	
	_morphology_used = morphology
	_scalar = positive_scalar
	_post_synaptic_current_multiplier = psp_multilpier
	_plasticity_flag = plasticity
	_plasticity_constant = plasticity_constant_ # not sure how to better segregate this name. Too Bad!
	_LTP_multiplier = ltp_multiplier
	_LTD_multiplier = ltd_multiplier

## Returns a dictionary of this object in the same format FEAGI expects
func to_FEAGI_JSON() -> Dictionary:
	if !_plasticity_flag:
		return {
			"morphology_id": _morphology_used.name,
			"morphology_scalar": FEAGIUtils.vector3i_to_array(_scalar),
			"postSynapticCurrent_multiplier": _post_synaptic_current_multiplier,
			"plasticity_flag": _plasticity_flag,
		}
	else:
		return {
			"morphology_id": _morphology_used.name,
			"morphology_scalar": FEAGIUtils.vector3i_to_array(_scalar),
			"postSynapticCurrent_multiplier": _post_synaptic_current_multiplier,
			"plasticity_flag": _plasticity_flag,
			"plasticity_constant": _plasticity_constant,
			"ltp_multiplier": _LTP_multiplier,
			"ltd_multiplier": _LTD_multiplier,
		}

## Returns if the morphology is not null and if it is found in the morphology cache
func is_morphology_valid() -> bool:
	if _morphology_used == null:
		return true
	return _morphology_used.name in FeagiCore.feagi_local_cache.morphologies.available_morphologies.keys()

## Is this a memory mapping (does it use the memory morphology)
func is_memory_mapping() -> bool:
	if _morphology_used == null:
		return false
	return _morphology_used.name == &"memory" # TODO this needs to be a reference
